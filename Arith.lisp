(defvar *arithmetic* '(arithHeuristic add1 mult7 addRandom power2 ))
(defvar *arithS* 2)
(defvar *arithG* 100)
(defvar *startnode* '(1 NIL 0 (- *arithG* *arithstart*)))

(defun currVgoal (node)
       (cond ((> (first node) *arithG*) NIL)
             (T T))
)

(defun createArithNode (newState node)
       (return-from createNode (list newState (first node) (+ (nth 2 node) 1) (arithHeuristic newState)))
)

(defun arithHeuristic (value)
       (return-from arithHeuristic (- *arithG* value))
)

(defun power2 (node heuristic)
       (cond ((currVgoal node)
             (let ((value 2) (x (first node)) (newnode NIL))
                  (declare integer value)
             (dotimes (n x)
                      (setq value (* 2 value))
             )
             (setq newnode (createNode value node heuristic))
             (cond ((currVgoal newnode) ;check after computation if still valid
                        (return-from power2 newnode))
                     (T (return-from power2 NIL))
             )))
             (T (return-from power2 NIL))
      )
)

(defun mult7 (node heuristic)
       (cond ((currVgoal node)
             (let ((value 2) (x (first node)) (newnode NIL))
                  (declare integer value)
             (setq value (* x 7))
             (setq newnode (createNode value node heuristic))
             (cond ((currVgoal newnode) ;check after computation if still valid
                        (return-from mult7 newnode))
                     (T (return-from mult7 NIL))
             )))
             (T (return-from mult7 NIL))
      )
)

(defun addRandom (node heuristic)
       (cond ((currVgoal node)
             (let ((value 2) (x (first node)) (newnode NIL))
                  (declare integer value)
             (setq value (+ x (RANDOM 100)))
             (setq newnode (createNode value node heuristic))
             (cond ((currVgoal newnode) ;check after computation if still valid
                        (return-from addRandom newnode))
                     (T (return-from addRandom NIL))
             )))
             (T (return-from addRandom NIL))
      )
)

(defun add1 (node heuristic)
       (cond ((currVgoal node)
             (let ((value 2) (x (first node)) (newnode NIL))
                  (declare integer value)
             (setq value (+ x 1))
             (setq newnode (createNode value node heuristic))
             (cond ((currVgoal newnode) ;check after computation if still valid
                        (return-from add1 newnode))
                     (T (return-from add1 NIL))
             )))
             (T (return-from add1 NIL))
      )

)
